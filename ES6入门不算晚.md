#### let和const命令
let所声明的变量，只在该命令所在的代码块内有效；

let不存在变量提升；

暂时性死区：使用let时，只要变量再还没有声明完成前使用，就会报错。

let不允许在相同作用域内重复声明同一个变量。

ES只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，具体的场景有哪些呢？比如：

* 第一种不合理场景：内层变量可能会覆盖外层变量，内部变量提升。
* 第二种不合理场景：用来计数的循环变量泄漏为全局变量，for循环中。
 
let为js新增块级作用域，有了块级作用域，外层作用域就无法读取内层作用域的变量，从而保证变量不会被覆盖。

**  ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。  **

块级作用域本质上是一个语句，不会有返回值，为了得到块级作用的域的返回值，办法就是给块级作用域前加上do，使他变成do表达式。
    
    let x = do {
  		let t = f();
  		t * t + 1;
	};
	
const声明一个只读常量，一旦声明，常量是不能改变的。对于const来说，只声明不赋值就会报错。但是和let命令一样，它的作用域只在声明所在的块级作用域内有效。

> const实际上保证的不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。


#### 变量的解构赋值

按照一定模式，从数组和对象中提取值，对变量进行赋值，被称为解构。 

解构分为两种情况：

*  “模式匹配”：只要等号两边的模式相同，左边的变量就会被赋予对应的值。
*  不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。

不理解Set结构，还有Generator函数。
***

解构赋值允许制定默认值。但是有一种情况，就是undefined。ES6内部使用严格相等运算符（===），判断一个位置是否有值，如果一个数组成员不严格等于undefined，默认值就不会生效。null不严格等于undefined。

    let { foo: baz } = { foo: "aaa", bar: "bbb" };
    baz // "aaa"
    foo // error: foo is not defined
  
对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是对应的变量，而不是同名的属性。代码中，foo是匹配模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。

对象的解构，默认值生效的条件是，对象的属性值严格等于undefined。

不能使用圆括号

1. 变量声明语句中，不能带有圆括号。
2. 函数参数中，模式不能带有圆括号。
3. 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。

然而可以使用圆括号的情况只有一种，赋值语句的非模式部分，可以使用圆括号。









